## 协程coroutines

### 编译使用协程

```bash
g++ -fcoroutines -std=c++20 
clang++ -std=c++20 -stdlib=libc++ -fcoroutines-ts
```



### Coroutine handles

> `co_await`作用：当`co_await a`时，编译器会创建一个coroutine_handle(协程句柄)并将其传递给方法`a.await_suspend`



下例为一个简单的协程例子，counter是一个计数器，关键在于控制可以在调用它的函数main1中counter中反复切换

`std::coroutine_handle<> *`调用counter，将其插入Awaiter中，在其await_suspend，这个类型将co_await产生的coroutine_handle存储到main1的协程句柄中，每次main1调用句柄时，都会触发一次counter中的循环，然后在`co_await`挂起，为简单起见，我们在每次调用await_suspend中都存储一下句柄，但该句柄并不会在调用之间改变。

句柄就像一个指向协程状态的指针，指针本身不变

> Awaiter::await_ready() false则co_await挂起函数，true则不挂起
>
> Awaiter::await_resume()在此返回void，但如果返回一个值，则该值为co_await表达式的值

```cc
#include <concepts>
#include <coroutine> // -fcoroutines
#include <cstddef>
#include <exception>
#include <iostream>
#include <unistd.h>
struct ReturnObject {
  struct promise_type {
    ReturnObject get_return_object() { return {}; }
    std::suspend_never initial_suspend() { return {}; }
    std::suspend_never final_suspend() noexcept { return {}; }
    void unhandled_exception() {}
  };
};

struct Awaiter {
  std::coroutine_handle<> *hp_;
  // await_ready() false则co_await挂起函数，true则不挂起
  constexpr bool await_ready() const noexcept { return false; }
  void await_suspend(std::coroutine_handle<> h) {
    if (hp_) {
      *hp_ = h;
      hp_ = NULL;
    }
  }

  constexpr void await_resume() const noexcept {}
};

ReturnObject counter(std::coroutine_handle<> *continuation_out) {
  Awaiter a{continuation_out};
  std::cout << "counter before for" << std::endl;
  for (unsigned i = 0;; i++) {
    std::cout << "before co_await" << std::endl;
    co_await a;
    std::cout << "counter : " << i << std::endl;
  }
}

void main1() {
  std::coroutine_handle<> h;
  counter(&h); // 第一次co_await从counter转到main1
  sleep(1);
  for (int i = 0; i < 3; ++i) {
    std::cout << "In main1 func\n";
    h(); // 每调用一次，调用一次counter到co_await
    sleep(1);
  }
  h.destroy();
}

int main() {
  main1();
  return 0;
}
```



### The coroutine return object

协程的返回类型(R)必须有嵌入类型promise_type，R::promise_type必须包含`get_return_object()`的结果是协程函数的返回值，上例中为counter()，R类型也称为future

如果我们可以直接从counter返回句柄，而不是通过传参就更好了。我们可以通过将协程句柄放在ReturnObject中来实现

由于`promise_type::get_return_object`计算返回对象，我们只需该方法将handle放入返回对象中，如何在`promise_type::get_return_object`获得一个句柄呢，由一个`coroutine_handle`引用的协程状态在一个已知的偏移量处包含了一个`promise_type`，因此`std::coroutine_handle`允许我们从promise对象计算一个句柄

任何类型T的`std::coroutine_handle<T>`都可以隐式转换为`std::coroutine_handle<void>`，可以使用静态函数`std::coroutine_handle::from_promise`来获取协程句柄

```cc
struct ReturnObject2 {
  struct promise_type {
    ReturnObject2 get_return_object() {
      return {.h_ = std::coroutine_handle<promise_type>::from_promise(*this)};
    }
    std::suspend_never initial_suspend() { return {}; }
    std::suspend_never final_suspend() noexcept { return {}; }
    void unhandled_exception() {}
  };
  ~ReturnObject2() { std::cout << "~ReturnObject2" << std::endl; }
  std::coroutine_handle<promise_type> h_;
  operator std::coroutine_handle<promise_type>() const { return h_; }
  operator std::coroutine_handle<>() const { return h_; }
};

ReturnObject2 counter2() {
  for (unsigned i = 0;; i++) {
    // std::cout << "before co_await" << std::endl;
    co_await std::suspend_always{};
    std::cout << "counter2 : " << i << std::endl;
  }
}

void main2() {
  // ReturnObject2在此处就已析构
  std::coroutine_handle<> h = counter2(); // "before co_await"
  for (int i = 0; i < 3; ++i) {
    std::cout << "In main2 func\n";
    h(); // 每调用一次，调用一次counter2到co_await
    sleep(1);
  }
  h.destroy();
}
/*
    before co_await
    ~ReturnObject2
    In main2 func
    counter2 : 0
    before co_await
    In main2 func
    counter2 : 1
    before co_await
    In main2 func
    counter2 : 2
    before co_await
*/
```

此时不再需要Awaiter保存句柄，因为句柄在ReturnObject2中，我们只需要`co_await std::suspend_always{};`，main2第一行中就被销毁，而我们将其句柄已复制到了h中，因此需要主动回收h的空间，如果有代码调用counter2并忽略了返回值ReturnObject2，将会导致内存泄漏



### The promise object

目前而言，还不能令人满意，尽管可以将控制从主程序和协程间相互传递，但并没有传递任何数据，我们可以向promise_type中添加一个value_字段，并使用该字段将值从协程中传递到主程序中，可以通`std::coroutine_handle<promise_type>::promise`可以获得所需的promise

`Awaiter::await_suspend`方法返回void，但其实也可返回bool，该情况下，如果返回false，则协程不会被挂起

一个协程实际上并没有被挂起，除非：

- 首先await_ready返回false
- 然后await_suspend（如果它返回类型bool而不是void）返回true。

因此定义了新类型GetPromise，包含字段`promise_type *p_`

```cc
template<typename PromiseType>
struct GetPromise {
    PromiseType *p_;
    bool await_ready() { return false; }
    bool await_suspend(std::coroutine_handle<PromiseType> h) {
        p_ = &h.promise();
        return false;	// 不需要挂起
    }
    PromiseType *await_resume() { return p_; }
};
```

`await_suspend`也可返回一个句柄，该情况下，返回的句柄会立刻恢复。GetPromise::await_suspend也可以返回句柄h来立刻恢复协程，而不是返回false，但是效率可能会降低

```cc
struct ReturnObject3 {
  struct promise_type {
    unsigned value_;
    ReturnObject3 get_return_object() {
      return {.h_ = std::coroutine_handle<promise_type>::from_promise(*this)};
    }
    std::suspend_never initial_suspend() { return {}; }
    std::suspend_never final_suspend() noexcept { return {}; }
    void unhandled_exception() {}
  };
  ~ReturnObject3() { std::cout << "~ReturnObject3" << std::endl; }
  std::coroutine_handle<promise_type> h_;
  operator std::coroutine_handle<promise_type>() const { return h_; }
  operator std::coroutine_handle<>() const { return h_; }
};

template <typename PromiseType> struct GetPromise {
  PromiseType *p_;
  bool await_ready() { return false; }
  bool await_suspend(std::coroutine_handle<PromiseType> h) {
    p_ = &h.promise();
    return false; // 不需要挂起
  }
  PromiseType *await_resume() { return p_; }
};

ReturnObject3 counter3() {
  auto pp = co_await GetPromise<ReturnObject3::promise_type>{};
  for (unsigned i = 0;; ++i) {
    pp->value_++;
    co_await std::suspend_always{};
  }
}

void main3() {
  std::coroutine_handle<ReturnObject3::promise_type> h = counter3();
  ReturnObject3::promise_type &promise = h.promise();
  for (int i = 0; i < 3; ++i) {
    std::cout << "counter3 : " << promise.value_ << std::endl;
    h();
  }
  h.destroy();
}
```



### The co_yield operator

由于协程获得promise太过笨重，从协程返回值`co_yield e`等价于`co_await p.yield_value(e)`

```cc
struct ReturnObject4 {
  struct promise_type {
    unsigned value_ = 0;
    ReturnObject4 get_return_object() {
      return {.h_ = std::coroutine_handle<promise_type>::from_promise(*this)};
    }
    std::suspend_never initial_suspend() { return {}; }
    std::suspend_never final_suspend() noexcept { return {}; }
    void unhandled_exception() {}
    std::suspend_always yield_value(unsigned value) {
      value_ = value;
      return {};
    }
  };
  ~ReturnObject4() { std::cout << "~ReturnObject4" << std::endl; }
  std::coroutine_handle<promise_type> h_;
  operator std::coroutine_handle<promise_type>() const { return h_; }
  operator std::coroutine_handle<>() const { return h_; }
};

ReturnObject4 counter4() {
  for (unsigned i = 0;; ++i) {
    co_yield i;   // == co_await promise.yield_value(i);
  }
}

void main4() {
  auto h = counter4().h_;
  auto &promise = h.promise();
  for (int i = 0; i < 3; ++i) {
    std::cout << "counter3 : " << promise.value_ << std::endl;
    h();
  }
  h.destroy();
}
```



### The co_return operator

想要在发出协程结束信号前只产生优先数量的值，该如何实现？

为表示协程的结束，C++添加了新的`co_return `操作符，有三种方式可以让协程结束

- 使用`co_return e  `，返回一个最终值e

  ```cc
  struct ReturnObject5 {
    struct promise_type {
      unsigned value_ = 0;
      ~promise_type() {
        std::cout << "~promise_type" << std::endl;
      }
      ReturnObject5 get_return_object() {
        return {.h_ = std::coroutine_handle<promise_type>::from_promise(*this)};
      }
      std::suspend_never initial_suspend() { return {}; }
      std::suspend_always final_suspend() noexcept { return {}; }  // 此处不同于之前例子，是suspend_always，否则会段错误
      void unhandled_exception() {}
      std::suspend_always yield_value(unsigned value) {
        value_ = value;
        return {};
      }
      // void return_void() {}
      void return_value(unsigned value) { value_ = value; }
      };
    ~ReturnObject5() { std::cout << "~ReturnObject5" << std::endl; }
    std::coroutine_handle<promise_type> h_;
    operator std::coroutine_handle<promise_type>() const { return h_; }
    operator std::coroutine_handle<>() const { return h_; }
  };
  
  ReturnObject5 counter5() {
    for (unsigned i = 0;i < 3; ++i) {
      co_yield i;   // == co_await promise.yield_value(i);
    }
    co_return 100; // 最终value_ = 100
  }
  
  void main5() {
    auto h = counter5().h_;
    auto &promise = h.promise();
    while(!h.done()) {
      std::cout << "counter5 : " << promise.value_ << std::endl;
      h();
    }
    std::cout << "done while" << std::endl;
    std::cout << "counter5 : " << promise.value_ << std::endl;
    h.destroy();
  }
  /*
      ~ReturnObject5
      counter5 : 0
      counter5 : 1
      counter5 : 2
      done while
      counter5 : 100
      ~promise_type
  */
  ```

- 使用`co_return `，表示最终不返回最终值

  ```cc
  struct ReturnObject5 {
    struct promise_type {
      unsigned value_ = 0;
      ~promise_type() {
        std::cout << "~promise_type" << std::endl;
      }
      ReturnObject5 get_return_object() {
        return {.h_ = std::coroutine_handle<promise_type>::from_promise(*this)};
      }
      std::suspend_never initial_suspend() { return {}; }
      std::suspend_always final_suspend() noexcept { return {}; }  // 此处不同于之前例子，是suspend_always，否则会段错误
      void unhandled_exception() {}
      std::suspend_always yield_value(unsigned value) {
        value_ = value;
        return {};
      }
      void return_void() {}
      // void return_value(unsigned value) { value_ = value; }
      };
    ~ReturnObject5() { std::cout << "~ReturnObject5" << std::endl; }
    std::coroutine_handle<promise_type> h_;
    operator std::coroutine_handle<promise_type>() const { return h_; }
    operator std::coroutine_handle<>() const { return h_; }
  };
  
  ReturnObject5 counter5() {
    for (unsigned i = 0;i < 3; ++i) {
      co_yield i;   // == co_await promise.yield_value(i);
    }
    co_return;
  }
  
  void main5() {
    auto h = counter5().h_;
    auto &promise = h.promise();
    while(!h.done()) {
      std::cout << "counter5 : " << promise.value_ << std::endl;
      h();
    }
    std::cout << "done while" << std::endl;
    std::cout << "counter5 : " << promise.value_ << std::endl;
    h.destroy();
  }
  /*
      ~ReturnObject5
      counter5 : 0
      counter5 : 1
      counter5 : 2
      done while
      counter5 : 2
      ~promise_type
  */
  ```

- 协程让执行从末尾结束，类似之前的例子

协程返回时，隐式地调用了`co_await promise.final_suspend()`，如果`final_suspend`挂起了协程，则协程状态将被最后一次更新且保持有效，直至调用句柄的`destroy()`，如果协程未被挂起，则协程会被自动销毁

如果在协程返回后仍需使用相关变量，则需设为`std::suspend_always final_suspend()`，如果不关心后续，则可以`std::suspend_never final_suspend()`

> ##### 如果`std::suspend_never final_suspend()`则可能导致段错误
>
> 如下所示，~promise_type表示已经析构，而`while(!h.done())`仍会继续进行，此时h是一个空指针，会引发未定义行为，导致程序崩溃
>
> ```cc
> /*
>     ~ReturnObject5
>     counter5 : 0
>     counter5 : 1
>     counter5 : 2
>     ~promise_type
>     counter5 : 4277075694
> */
> ```
>
> 



### 通用生成器示例

之前我们用空函数来抑制所有异常发生，即空的`unhandled_exception()`

可以通过`unhandled_exception()`调用`std::current_exception`去获得`std::exception_ptr`，当exception_ptr非空时，使用`std::rethrow_exception`传递异常

```cc
template<typename T>
struct Generator {
  struct promise_type;
  using handle_type = std::coroutine_handle<promise_type>;
  struct promise_type {
    T value_;
    std::exception_ptr exception_;
    Generator get_return_object() {
      return Generator(handle_type::from_promise(*this));
    }
    std::suspend_always initial_suspend() { return {}; }
    std::suspend_always final_suspend() noexcept { return {}; }
    void unhandled_exception() { exception_ = std::current_exception(); }
    
    std::suspend_always yield_value(T &&t) {
      value_ = std::forward<T>(t);
      return {};
    }

    void return_void() {}
  };
  handle_type h_;
  Generator(handle_type h) : h_(h) {}
  ~Generator() { h_.destroy(); }

  explicit operator bool() {
    fill();
    return !h_.done();
  }
  T operator()() {
    fill();
    full_ = false;
    return std::move(h_.promise().value_);
  }
private:
  bool full_ = false;
  void fill() {
    if (!full_) {
      h_();
      if (h_.promise().exception_)
        std::rethrow_exception(h_.promise().exception_);
      full_ = true;
    }
  }
};

Generator<unsigned> counter6() {
  for (unsigned i = 0;i < 3;) {
    co_yield i++;   // == co_await promise.yield_value(i);
  }
}

void main6() {
  auto gen = counter6();
  while (gen)
  {
    std::cout << "counter6 : " << gen() << std::endl;
  }
}
```

