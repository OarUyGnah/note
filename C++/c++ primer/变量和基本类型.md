# const限定符

`const int a;//error 必须声明时初始化`

编译初始化时`const int bufsize = 512;`

编译器会将在编译过程中把用到该变量的地方都换成对应的值

**如果想在多个文件间共享const对象，必须在定义之前添加extern关键字**

## 1	const引用

```cpp
const int ci = 1024;
const int &r1 = ci;
r1 = 42;//error
int &r2 = ci;//error 企图让一个非常量引用去指向一个常量对象
```

**引用的类型必须与其所引用对象一致（const int 和int 不是同一类型），但有两个例外：**

- 初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可

  ```
  double dval = 3.14;
  const int &ri = dval;	//ok，但int &rnc = dval会报错
                          //编译器将上述代码变成如下形式
                          //const int temp = dval;
                          //const int &ri = temp;
                          //ri绑定了一个临时量对象
  ```

  允许一个常量引用绑定非常量的对象、字面值，甚至是一个一般表达式

  ```cpp
  int i = 42;
  const int &r1 = i;//允许将一个const int&绑定到普通int（只是保证r1不能修改值而已）
  const int &r2 =42;//ok
  const int &r3 = r1 * 2;//ok
  int &r4 = r1 * 2;//error r4是一个普通的非常量引用
  ```

## 2	指针和const

**指向常量的指针不能用于改变其所指对象的值**

```cpp
const double pi = 3.14;			//常量
double* ptr = &pi;				//error，因为如果时double* 则可以通过ptr修改pi常量的值，不合理
const double *cptr = &pi;		//ok
*cptr = 42;						//error
double dval = 3.14;
cptr = &dval; 					//ok,但不能通过cptr修改dval的值
```

#### const 指针

```
int errnum = 0;
int *const curerr = &errnum;	//curerr将一直指向errnum
const double pi = 3.14159;
const double *const pip = &pi;	//pip是一个指向常量对象的常量指针
```

## 3	顶层const

- #### **顶层const：指针本身是常量**

- #### **底层const：指针所指对象是常量**

**指针类型左底右顶**

```cpp
int i = 0;
int *const p1 = &i;			//不能改变p1，顶层
const int ci = 42;			//不能改变ci，顶层
const int *p2 = &ci;		//不能改变ci，允许改变p2，底层
const int *const p3 = p2;	//左底右顶
const int &r = ci;			//用于声明引用的const都是底层
```

1. #### 执行**对象拷贝操作，顶层const不受什么影响**

   ```cpp
   i = ci;	//ok  ci是顶层const，对此操作无影响
   p2 = p3;//ok  p2和p3指向的对象类型相同，p3顶层const部分不影响
   ```

2. #### **底层const的限制不能忽视，拷入和拷出的对象必须具有相同的底层资格，或者两个对象数据类型必须能够转换（一般来说，非const可以转换为const）**

   ```cpp
   int *p = p3;		//error p3包含底层const，p没有
   p2 = p3;			//ok	p2 p3底层const相同，顶层不影响
   p2 = &i;			//ok	int* 能转化为const int*
   int &i = ci;		//error	普通int&不能绑定到const int，否则i可以修改ci值
   const int &r2 = i;	//ok 	const int可以绑定到普通int上
   ```

   #### **技巧：去看自己定义的新变量，如果能通过操作新的变量从而影响被引用的值时，则被影响的值不能是const**

   ​		**例如int i =100;const int &r2=i;则r2的改变不会影响i，就没问题**

   ​		**而const int ii =100; int& rii=ii;若编译成功，则可以通过rii去修改i的值，而ii不允许修改，则error**

## 4	constexpr和常量表达式

#### 常量表达式：值不会改变并且在编译过程就能得到计算结果的表达式

```cpp
const int maxfiles = 20;			//是常量表达式
const int limit = maxfiles + 1;		//limit是
int staff_size = 27;				//不是，值会改变
const int sz = get_size();			//sz不是，sz本身是常量，但是要到运行期才能确定值
```

#### **c++11规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式**

```cpp
constexpr int mf = 20;			//20是常量表达式
cosntexpr int limit = mf + 1;	//mf+1是常量表达式
constexpr int sz = size(); 		//只有当size是constexpr函数时才是正确的
```

**constexpr指针必须是nullptr或0，或者是存储于某个固定地址的对象**

### 指针和const

​	在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指对象无关

```cpp
const int *p = nullptr;			//p是一个指向整数常量的指针
constexpr int *q = nullptr;		//q是一个指向整数的整形常量
								//关键在于constexpr把它所定义的对象置为顶层const，即指针本身为常量
```

### constexpr函数

- 函数返回类型、所有形参类型必须是字面值类型
- 函数中必须有且只有一个return
- 为了能在编译过程随时展开，constexpr函数被隐式地指定为inline函数

```cpp
constexpr size_t scale(size_t size){
	//允许返回值不是常量
	return new_sz() * size;
}
//当scale实参是常量表达式，它的返回值也是常量表达式；反之则不然
int arr[scale(2)];	//ok	scale(2)是常量表达式
int i = 2;
int arr2[scale(i)];	//error! scale(i)不是常量表达式
```



### constexpr构造函数

- 聚合类
  - 满足以下定义
    - 所有成员都是public
    - 没有定义任何构造函数
    - 没有类内初始值
    - 没有基类，也没有virtual函数
- 字面值常量类
  - 数据成员都是字面值类型的聚合类是字面值常量类
  - 或满足下述要求
    - 数据成员都必须是字面值类型
    - 类必须至少含有一个constexpr构造函数
    - 如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的constexpr构造函数
    - 类必须使用析构函数的默认定义，该成员负责销毁类的对象

#### 字面值常量类的构造函数可以是constexpr函数

- 一个字面值常量类至少要提供一个constexpr构造函数
- constexpr构造函数必须初始化所有数据成员