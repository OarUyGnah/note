## 类成员指针

可以指向类的非静态成员的指针

```cc
class Screen {
public:
	typedef std::string::size_type pos;
	char get_cursor() const { return contents[cursor]; }
	char get() const;
	char get(pos ht,pos wd) const;
    	
    // 一个静态函数data,返回一个成员指针
    static const std::string Screen::* data() {
        return &Screen::contents;
    }
    
private:
	std::string contents;
	pos cursor;
	pos height,width;
};
```

```cc
// pdata可以指向一个常量(非常量)Screen对象的string成员
const string Screen::*pdata;

pdata = &Screen::contents;

Screen myScreen, *pScreen = &myScreen;
// 获得myScreen对象的contents成员
auto s = myScreen.*pdata;
s = pScreen->*pdata;

const std::string Screen::*pdata = Screen::data();
autp ss = myScreen.*pdata;
```



### 成员函数指针

如果成员函数是const成员或引用成员，则必须将const限定符或引用限定符包含

```cc
char (Screen::*pmf2)(Screen::pos ht,Screen::pos wd) const;
pmf2 = &Screen::get;  // 必须显式使用取址运算符&

(myScreen.*pmf2).(0,0); // 括号不可少
```

#### 类型别名

```cc
using Action = char (Screen::*)(Screen::pos ht,Screen::pos wd) const;
Action aget = &Screen::get;

Screen& action(Screen&, Action = &Screen::get);
action(myScreen);		// ok
action(myScreen,aget); 	// ok
action(myScreen,&Screen::get); // ok
```

#### 成员指针函数表

```cc
class Screen {
public:
    using Action = Screen& (Screen::*)();
    enum Directions { HOME,FORWARD,BACK,UP,DOWN };
  	Screen& move(Directions);
    Screen& home();
    Screen& forward();
    Screen& back();
    Screen& up();
    Screen& down();
private:
    static Action Menu[];	// 函数表
};

Screen::Action Screen::Menu[] = {
    &Screen::home,
    &Screen::forward,
    &Screen::back,
    &Screen::up,
    &Screen::down
};

Screen& Screen::move(Directions cm) {
    return (this->*Menu[cm])(); // Menu[cm]指向一个成员函数
}
```

```cc
Screen s;
s.move(Screen::HOME); // 调用s.home
```

#### 成员函数用作可调用对象

成员指针不是可调用对象，不能直接将一个指向成员函数的指针传递给算法

想要通过成员指针调用函数，必须使用`->*`

```cc
auto fp = &string::empty;
find_if(s.begin(),s.end(),fp); // error 必须使用.*或->*调用成员函数
```

##### 使用function生成一个可调用对象

```cc
std::function<bool(const std::string&)> fcn = &string::empty;
find_if(s.begin(),s.end(),fcn); // ok
```

##### 使用mem_fn生成一个可调用对象

```cc
find_if(s.begin(),s.end(),std::mem_fn(&string::empty));
```

```cc
auto f = mem_fn(&string::empty);
f(*svec.begin());	// ok 传入一个string对象，f使用.*调用empty
f(&svec[0]);		// ok 传入一个string*，f使用->*调用empty
```

