### 动态库和静态库
---
[静态链接和静态库实践指北-原理篇](https://zhuanlan.zhihu.com/p/595527528)

目录结构：

```bash
.
├── include
│   ├── head.h
│   └── note.md
├── lib
│   └── libMyCal.a
├── main.c
└── src
    ├── add.c
    ├── div.c
    ├── mul.c
    └── sub.c
```

1. 静态库
    + 生成.o文件：`gcc *.c -c -I../include`
    + 制作静态库：`ar -cr libMyCal.a  *.o`
    + 使用:
        + `gcc main.c  lib/libMyCal.a  -o main -I./include`
        + `gcc main.c -I ./include -L lib -l MyCal -o main_`

2.  动态库
    + 制作： gcc -c -fPIC -I ../include *.c
    + 生成： gcc -shared -o libMyCal.so -I ../include *.o
    + 使用：
        + `gcc main.c lib/libMyCal.so -o m -I ./include`
        + `gcc main.c -I ./include -L lib -l MyCal -o main_`
          
            但是这么写会报错：
            ```
            ./ main_: error while loading shared libraries: 
                libMyCal.so: cannot open shared object file: No such file or directory
            ```

            解决方法是：
                
            + 将libMyCal.so放到系统的lib下，放的也都是动态链接库: `sudo cp ./lib/libMyCal.so  /lib/`
              
                再去执行`./main_` 就能顺利编译

                可用`ldd` 命令查看 `main_`的依赖项目：
                
                ```bash
                (base) szz@szz:/media/szz/Others/Self_study/Cpp/Study/sdll$ ldd main_ 
                    linux-vdso.so.1 =>  (0x00007fff07e96000)                          # shared object file
                    libMyCal.so => /lib/libMyCal.so (0x00007fd692a86000)              # 动态库    
                    libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fd6926bc000) # 系统的C库
                    /lib64/ld-linux-x86-64.so.2 (0x00007fd692c88000)                  # 动态链接器
                ```
            
            +  加入搜索路径：`export LD_LIBRARY_PATH=./lib/`

                直接将动态库放到系统的动态库中，很不安全，因此可能会覆盖重名的系统库。更加安全的方式是通过`LD_LIBRARY_PATH`使得系统在搜索环境变量之前搜索这个路径。 

                ```bash
                linux-vdso.so.1 =>  (0x00007ffce2710000)
                libMyCal.so => ./lib/libMyCal.so (0x00007fee92742000)               # 与上面解决方案对应路径不同
                libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fee92378000)
                /lib64/ld-linux-x86-64.so.2 (0x00007fee92944000)

                ```

                注意： 这个方案是临时的，用于测试使用，想要永久生效，**需要将上述命令中的相对路径换成绝对路径加入`.bashrc`文件中**。
            

            + 第四种解决方案


        + 动态库的优、缺点：
            + 体积小； 动态库更新了，不需要重新编译程序(只要函数接口没变)
            + 加载速度相对静态库慢一点


静态库链接仅仅是用ar将.o文件进行合并，而不是使用ld链接

动态库和可执行文件的链接过程都调用了/usr/bin/c++(封装了ld链接器)，进行了真正意义的链接，例如合并相似段、地址分配和符号重定向，但重定向仅仅做了地址偏移量计算，并不会真正的地址重定向，地址重定向要在装载时由动态链接器完成

### 问题 ：静态链接和编译静态库是同一个概念吗？它们有区别吗？

不是同一个概念。很明显，它们不是同一个概念，"静态链接" 强调的指的是，编译可执行文件或动态库时，去链接一个静态库. a，其实相当于链接了一堆已经被编译好的. o，然后使用 ld 执行执行相似段合并、地址分配和重定向，对于编译可执行文件和动态库而言，“静态链接” 一定发生了真正的链接。但是对于编译静态库而言，“静态链接” 只是个幌子。而编译静态库，本质上只是对. o 文件的打包合并，可以认为它和真正的链接过程并没有什么关系。

### 静态库全局变量初始化问题

[静态库中全局变量的初始化问题 - loop_in_codes - C++博客 (cppblog.com)](http://www.cppblog.com/kevinlynx/archive/2014/05/15/105885.html)