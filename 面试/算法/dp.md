## 1、计算所有子字符串权值

> 小美定义一个 01 串的权值为：每次操作选择一位取反，使得相邻字符都不相等的最小操作次数。
> 例如，"10001"的权值是 1，因为只需要修改一次：对第三个字符取反即可。
> 现在小美拿到了一个 01 串，她希望你求出所有非空连续子串的权值之和，你能帮帮她吗？

1、暴力

只有可能变为010101...或者101010...，就将每个子串和他们对比，然后取出最小的值即为权值

2、dp

举个例子，比如在计算`s`的子串 `subs = "1000"`的权值时，我们已经计算过`subs`的子串`subsubs = "100"`的权值，这就造成了一种计算资源的浪费。如果我们把`subsubs = "100"`的权值计算完后保存了下来，这里为`1`， 那么，当我们遇到字符串 `subs = "1000"`时，只需要比较最后多出来的一位是否与可能的目标字符串相同即可，如果相等，则`subs = "1000"`的权值为`subsubs = "100"`的权值 `+1`，否则等于`subsubs = "100"`的权值。



```cc
#include <iostream>
#include <string>
#include <vector>
using namespace std;

int main() {
    string s;
    cin >> s;

    int res = 0, n = s.length();
    // s1 101010..., s2 010101...
    string s1 = "", s2 = "";
    vector<vector<int>> nums(n-1, vector<int>(2, 0));
    // 构建两个进行比较的字符串
    for (int i = 0; i <= n/2; ++i) {
        s1 += '1'; s1 += '0';
        s2 += '0'; s2 += '1';
    }
    for (int i = 0; i < n -1; ++i) {
        for (int j = i; j < n; ++j) {
            // 和当前的位置的两个字符串比较，如果当前值不同，就要增加权值
            if (s[j] != s1[j]) nums[i][0]++;
            if (s[j] != s2[j]) nums[i][1]++;
            // 取二者值最小的为当前子串的权值
            res += min(nums[i][0], nums[i][1]);
        }
    }

    printf("%lld\n", res);
}
```

2、

>小美拿到了一个数组*a*，她准备构造一个数组b*满足：
>
>1. sum(a) == sum(b)
>2. 每个位置的元素a和b的都不同
>3. b均为正整数

