#### **孤儿进程：**

**一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。**

#### **僵尸进程：**

**一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。**

**问题及危害**

如果进程不调用wait / waitpid的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为**没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害**，应当避免。

孤儿进程是没有父进程的进程，**孤儿进程这个重任就落到了init进程身上,因此孤儿进程并不会有什么危害**。任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。

#### 避免僵尸进程的方法：

1.一般僵尸进程很难直接kill掉，不过您可以kill僵尸爸爸。父进程死后，僵尸进程成为”孤儿进程”，过继给1号进程init，init始终会负责清理僵尸进程．它产生的所有僵尸进程也跟着消失。

2.用wait()函数使父进程阻塞:wait函数将使其调用者阻塞，直到其某个子进程终止。故父进程可调用wait函数回收其僵尸子进程。除此之外，waitpid函数提供更为详尽的功能( 增加了非阻塞功能以及指定等待功能 )

3.使用信号量，在signal handler 中调用waitpid,这样父进程不用阻塞:子进程死后，会发送SIGCHLD信号给父进程，父进程收到此信号后，执行waitpid()函数为子进程收尸。就是基于这样的原理：就算父进程没有调用wait，内核也会向它发送SIGCHLD消息，而此时，尽管对它的默认处理是忽略，如果想响应这个消息，可以设置一个处理函数。