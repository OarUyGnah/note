## 遍历

### 前序

```cc
class Solution {
public:
    // 递归
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> ret;
        traversal(root,ret);
        return ret;
    }
    void traversal(TreeNode* cur, vector<int>& vec) {
        if (cur == NULL) return;
        vec.push_back(cur->val);    // 中
        traversal(cur->left, vec);  // 左
        traversal(cur->right, vec); // 右
    }
	
    // 迭代
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> ret;
        stack<TreeNode*> st;
        if(!root) return ret;
        st.push(root);
        while(!st.empty()) {
            TreeNode* node = st.top();
            st.pop();
            ret.push_back(node->val);
            if(node->right) {   // 栈要左节点先出，因此先放入右节点
                st.push(node->right);
            }
            if(node->left) {
                st.push(node->left);
            }
            
        }
        return ret;
    }

    /*          统一迭代法           */
    // 中左右 放栈中为 右左中
    vector<int> preorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> result;
        if (root == NULL) return result;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            if(node != nullptr) {
                st.pop();
                if(node->right) st.push(node->right);	// 右
                if(node->left) st.push(node->left);		// 左
                st.push(node);	// 中
                st.push(nullptr);
            } else {
                st.pop();   // pop nullptr
                TreeNode* node = st.top();
                st.pop();
                result.push_back(node->val);
            }
        }
        return result;
    }
    
};
```



### 中序

```cc
class Solution {
public:
    // 递归
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> ret;
        traversal(root,ret);
        return ret;
    }
    void traversal(TreeNode* cur, vector<int>& vec) {
        if (cur == NULL) return;
        traversal(cur->left, vec);  // 左
        vec.push_back(cur->val);    // 中
        traversal(cur->right, vec); // 右
    }

    // 迭代
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        TreeNode* cur = root;
        while (cur != NULL || !st.empty()) {
            if (cur != NULL) { // 指针来访问节点，一直访问到最左下
                st.push(cur); // 将访问的节点放进栈
                cur = cur->left;                // 左
            } else {
                cur = st.top(); // 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）
                st.pop();
                result.push_back(cur->val);     // 中
                cur = cur->right;               // 开始遍历右子树
            }
        }
        return result;
    }
    
    /*          统一迭代法           */
    // 左中右 放栈中为 右中左
    vector<int> inorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> result;
        if (root == NULL) return result;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            if(node != nullptr) {
                st.pop();
                if(node->right) st.push(node->right);
                st.push(node);
                st.push(nullptr);
                if(node->left) st.push(node->left);
            } else {
                st.pop();
                TreeNode* node = st.top();
                st.pop();
                result.push_back(node->val);
            }
        }
        return result;
    }
};
```



### 后序

```cc
class Solution {
public:
    /*              递归                */
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> ret;
        traversal(root,ret);
        return ret;
    }
    void traversal(TreeNode* cur, vector<int>& vec) {
        if (cur == NULL) return;
        traversal(cur->left, vec);  // 左
        traversal(cur->right, vec); // 右
        vec.push_back(cur->val);    // 中
    }

    /*              迭代                */
    // 先序遍历是 中左右   将左右顺序修改为 中右左   在reverse 变为后序遍历 左右中
    vector<int> postorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> result;
        if (root == NULL) return result;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            st.pop();
            result.push_back(node->val);
            if (node->left) st.push(node->left); // 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）
            if (node->right) st.push(node->right); // 空节点不入栈
        }
        reverse(result.begin(), result.end()); // 将结果反转之后就是左右中的顺序了
        return result;
    }
    
    /*          统一迭代法           */
    // 左右中   放入栈为 中右左
    vector<int> postorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> result;
        if (root == NULL) return result;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            if(node != nullptr) {
                st.pop();
                st.push(node);
                st.push(nullptr);   // 当前处理的节点需要再push一个nullptr
                if(node->right) st.push(node->right);
                if(node->left) st.push(node->left);
            } else {
                st.pop();
                TreeNode* node = st.top();
                st.pop();
                result.push_back(node->val);
            }
        }
        return result;
    }

};
```



### 层次遍历

#### 迭代法

```cc
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        vector<vector<int>> result;
        while (!que.empty()) {
            int size = que.size();
            vector<int> vec;
            // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                vec.push_back(node->val);
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(vec);
        }
        return result;
    }
};
```

#### 递归法

```cc
class Solution {
public:
    void order(TreeNode* cur, vector<vector<int>>& result, int depth)
    {
        if (cur == nullptr) return;
        if (result.size() == depth) result.push_back(vector<int>());
        result[depth].push_back(cur->val);
        order(cur->left, result, depth + 1);
        order(cur->right, result, depth + 1);
    }
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> result;
        int depth = 0;
        order(root, result, depth);
        return result;
    }
};
```

